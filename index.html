<head>
  <title>Milan x Rome - Roam Map</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
    }
    #map {
      height: 100vh;
      width: 100vw;
    }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      z-index: 1000;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      background: rgba(255,255,255,0.9);
      padding: 8px;
      border-radius: 8px;
    }
    .controls select,
    .controls button {
      font-size: 14px;
      padding: 5px;
      flex: 1 1 120px;
    }
  </style>
</head>
<body>
<div class="controls">
  <input type="text" id="vibeSearchInput" placeholder="What's the vibe..." />
<select id="themeDropdown">
  <option value="">Select Theme</option>
  <option value="aperitivo hour">Aperitivo Hour</option>
  <option value="foodie feast">Foodie Feast</option>
  <option value="wine & dine">Wine & Dine</option>
  <option value="gallery & grandeur">Gallery & Grandeur</option>
  <option value="leisure & landmarks">Leisure & Landmarks</option>
  <option value="photo walk">Photo Walk</option>
  <option value="family day out">Family Day Out</option>
  <option value="night on the town">Night on the Town</option>
  <option value="mindful mornings">Mindful Mornings</option>
  <option value="midday recharge">Midday Recharge</option>
</select>
  <select id="neighborhood-input">
  <option value="">Select Neighborhood</option>

  <optgroup label="Milan">
    <option value="centro storico">Centro Storico</option>
    <option value="brera">Brera</option>
    <option value="navigli">Navigli</option>
    <option value="porta romana">Porta Romana</option>
    <option value="porta venezia">Porta Venezia</option>
    <option value="porta nuova">Porta Nuova</option>
    <option value="isola">Isola</option>
    <option value="ticinese">Ticinese</option>
    <option value="corso buenos aires">Corso Buenos Aires</option>
    <option value="cittÃ  studi">CittÃ  Studi</option>
    <option value="zona tortona">Zona Tortona</option>
    <option value="moscova">Moscova</option>
  </optgroup>

  <optgroup label="Rome">
    <option value="aventino">Aventino</option>
    <option value="centro storico">Centro Storico</option>
    <option value="esquilino">Esquilino</option>
    <option value="flaminio">Flaminio</option>
    <option value="garbatella">Garbatella</option>
    <option value="monteverde">Monteverde</option>
    <option value="monti">Monti</option>
    <option value="parioli">Parioli</option>
    <option value="pigneto">Pigneto</option>
    <option value="prati">Prati</option>
    <option value="san lorenzo">San Lorenzo</option>
    <option value="testaccio">Testaccio</option>
    <option value="trastevere">Trastevere</option>
  </optgroup>
</select>

  <select id="priceFilter">
    <option value="">Price</option>
    <option value="$">$</option>
    <option value="$$">$$</option>
    <option value="$$$">$$$</option>
    <option value="$$$$">$$$$</option>
  </select>
  <select id="durationDropdown">
    <option value="medium">How Long?</option>
    <option value="short">Short (â‰¤2h)</option>
    <option value="medium">Medium (2.5â€“5h)</option>
    <option value="long">Long (5.5â€“8h)</option>
  </select>
  <button id="crawlNowBtn">Crawl Now</button>
  <button id="saveRouteBtn">Save Route</button>
<button id="clearRouteBtn">Clear Route</button>
<button id="favoritesBtn">My Favorites</button>
<label><input type="checkbox" id="liveToggle" /> Only Show Live</label>
</div>
<div id="map"></div>
<div id="crawlSummary" style="display:none; padding: 16px; background: #fff; border: 2px solid #333; max-width: 300px; position: absolute; top: 20px; right: 20px; z-index: 9999; box-shadow: 0 0 10px rgba(0,0,0,0.2); border-radius: 8px;">
    <!-- Populated by JS -->
  </div>
  <div id="routePreview" style="
  position: fixed;
  top: 80px;
  right: 0;
  width: 250px;
  max-height: 90vh;
  overflow-y: auto;
  background: white;
  border-left: 2px solid #ccc;
  box-shadow: -2px 0 5px rgba(0,0,0,0.1);
  padding: 10px;
  display: none;
  z-index: 1000;
">
  <h4>ðŸ§­ Route Preview</h4>
  <ol id="routeList"></ol>
</div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
<script>
const defaultIcon = L.icon({
  iconUrl: 'https://unpkg.com/leaflet@1.9.3/dist/images/marker-icon.png',
  shadowUrl: 'https://unpkg.com/leaflet@1.9.3/dist/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});

  let allLocations = [];
  
const map = L.map('map', {
  zoomControl: false
});

// Add zoom control to bottom left
L.control.zoom({ position: 'bottomleft' }).addTo(map);

// Add dark basemap
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap contributors & Carto',
  subdomains: 'abcd',
  maxZoom: 19
}).addTo(map);

// Fit bounds to Milan and Rome
const bounds = L.latLngBounds([
  [41.9028, 12.4534], // Rome
  [45.4642, 9.1900]   // Milan
]);
map.fitBounds(bounds);

// --- Geolocation: Center map and show user's location if permitted ---
if (navigator.geolocation) {
  navigator.geolocation.getCurrentPosition(
    (pos) => {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;

      const userMarker = L.marker([lat, lon], {
        icon: L.icon({
          iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684908.png',
          iconSize: [32, 32],
          iconAnchor: [16, 32],
          popupAnchor: [0, -32]
        })
      }).addTo(map).bindPopup("You are here").openPopup();

      map.setView([lat, lon], 14); // Center map on user's location
    },
    (err) => {
      console.warn("Geolocation not allowed or failed:", err);
    }
  );
} else {
  console.warn("Geolocation not supported in this browser.");
}

  const dayPartColors = {
  M: 'blue',         // Morning
  MD: 'green',       // Midday
  A: 'orange',       // Afternoon
  HH: 'gold',      // Happy Hour 
  E: 'violet',          // Evening
  L: 'red'         // Late Night 
};


  // ðŸ” REPLACE your current isLocationOpenNow with this version
function isLocationOpenNow(ev) {
  const now = new Date();
  const dayKeys = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  const todayKey = dayKeys[now.getDay()];
  const yesterdayKey = dayKeys[(now.getDay() + 6) % 7];

  // Use fractional hour for better accuracy (e.g., 21.5 for 9:30 PM)
  const currentHour = now.getHours() + now.getMinutes() / 60;

  const todayHours = ev.hoursNumeric?.[todayKey];
  const yesterdayHours = ev.hoursNumeric?.[yesterdayKey];

  // Normalize to an array of ranges
  const normalizeRanges = (h) =>
    Array.isArray(h) ? h : (h && typeof h === 'object' ? [h] : []);

  const todayRanges = normalizeRanges(todayHours);
  const yRanges = normalizeRanges(yesterdayHours);

  const isWithin = (open, close) => {
    // Over-midnight window (e.g., 18 â†’ 26)
    if (close < open) return currentHour >= open || currentHour < close;
    return currentHour >= open && currentHour < close;
  };

  // Still open from **yesterday** (handles over-midnight spill)
  if (yRanges.some(r =>
    Number.isFinite(r.open) && Number.isFinite(r.close) &&
    r.close < r.open && currentHour < r.close
  )) {
    return true;
  }

  // Open during **today** in any range
  if (todayRanges.some(r =>
    Number.isFinite(r.open) && Number.isFinite(r.close) &&
    isWithin(r.open, r.close)
  )) {
    return true;
  }

  return false;
}

  
  let globalEvents = [];
let allMarkers = [];
let selectedRoute = [];
let currentRoute = null;
const maxRouteStops = 5;
  let savedRoutes = [];
  let eventsToday = [];

// â”€â”€â”€ DRAW ROUTE FUNCTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawRoute() {
console.log("Redrawing route for stops:", selectedRoute);
  
  if (currentRoute) {
    map.removeControl(currentRoute);
    currentRoute = null;
  }
  if (selectedRoute.length < 2) return;

  const waypoints = selectedRoute.map(loc => L.latLng(loc.lat, loc.lon));
  currentRoute = L.Routing.control({
    waypoints,
    routeWhileDragging: false,
    draggableWaypoints: false,
    addWaypoints: false,
    show: false,
    createMarker: () => null, // Hide default markers
    lineOptions: {
      styles: [{ color: 'red', opacity: 0.9, weight: 5 }]
    },
  }).addTo(map);
}

  // â”€â”€â”€ ROUTE PREVIEW FUNCTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function updateRoutePreview() {
  const container = document.getElementById('routePreview');
  const list = document.getElementById('routeList');

  if (selectedRoute.length === 0) {
    container.style.display = 'none';
    list.innerHTML = '';
    return;
  }

  container.style.display = 'block';
  list.innerHTML = '';

  selectedRoute.forEach((stop, idx) => {
    const item = document.createElement('li');
    item.textContent = stop.name;

    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'âŒ';
    removeBtn.style.marginLeft = '10px';
    removeBtn.onclick = () => {
      selectedRoute.splice(idx, 1);
      drawRoute();
      updateRoutePreview();
    };

    item.appendChild(removeBtn);
    list.appendChild(item);
  });
}

// â”€â”€â”€ ADD TO ROUTE HANDLER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addToRoute(ev) {
  console.log("addToRoute invoked", ev.name, selectedRoute.length);

  if (selectedRoute.length >= maxRouteStops) {
    alert(`You can add up to ${maxRouteStops} stops only.`);
    return;
  }

  if (selectedRoute.some(loc => loc.name === ev.name)) {
    alert('This location is already in your route.');
    return;
  }

  selectedRoute.push(ev);
  console.log("âœ… Location added to route:", ev.name);
  console.log("ðŸ§­ Route now has:", selectedRoute.map(s => s.name));

  drawRoute();

  if (selectedRoute.length >= 2) {
    setTimeout(showRouteControls, 100); // ensures DOM is ready
  }

  updateRoutePreview(); // this shows the list of stops on the right side
}

// Save a single venue to "My Favorites" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function saveVenueToFavorites(ev) {
  try {
    const key = 'savedFavorites'; // keep routes under 'savedRoutes' and singles under 'savedFavorites'
    const existing = localStorage.getItem(key);
    const favorites = existing ? JSON.parse(existing) : [];

    // de-dupe by id or name
    const vid = ev.id || ev.name;
    const already = favorites.some(f => (f.id || f.name) === vid);
    if (already) {
      alert('Already in My Favorites.');
      return;
    }

    // store a compact record (extend if you want)
    favorites.push({
      id: ev.id || null,
      name: ev.name,
      lat: parseFloat(ev.lat),
      lon: parseFloat(ev.lon),
      link: ev.link || '',
      vibe: ev.vibe || '',
      price: ev.price || '',
      tags: ev.tags || '',
      addedAt: Date.now()
    });

    localStorage.setItem(key, JSON.stringify(favorites));
    alert(`Added â€œ${ev.name}â€ to My Favorites!`);
  } catch (e) {
    console.warn('saveVenueToFavorites failed:', e);
    alert('Could not save to favorites.');
  }
}

function getSavedRoutes() {
  try { return JSON.parse(localStorage.getItem('savedRoutes') || '[]'); } catch { return []; }
}
function setSavedRoutes(list) { localStorage.setItem('savedRoutes', JSON.stringify(list || [])); }

function getSavedFavorites() {
  try { return JSON.parse(localStorage.getItem('savedFavorites') || '[]'); } catch { return []; }
}
function setSavedFavorites(list) { localStorage.setItem('savedFavorites', JSON.stringify(list || [])); }

function buildRouteIds(routeArr) {
  return (routeArr || []).map(x => (x.id || x.name)).join(',');
}
function buildRouteShareUrl(routeArr) {
  const url = new URL(location.href);
  url.searchParams.set('route', buildRouteIds(routeArr));
  return url.toString();
}

  // âœ… Add photo cover helper functions here (before renderMarkers)
function slugifyName(name = '') {
  return String(name)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');
}

// Build an ordered list of possible image URLs.
// Adjust the paths to match your repo structure if different.
function coverCandidates(ev) {
  const s = slugifyName(ev.name || '');
  const guesses = [
    ev.cover || null,                                       // explicit
    `img/venues/${s}/cover.jpg`,
    `img/venues/${s}/cover.webp`,
    `img/venues/${s}/cover.png`,
    `img/venues/${s}.jpg`,
    `img/venues/${s}.webp`,
    `img/venues/${s}.png`
  ].filter(Boolean);
  // Dedupe while preserving order
  return [...new Set(guesses)];
}

// Called by <img onerror> to try the next candidate, or remove the image
function tryNextCover(imgEl) {
  try {
    const list = (imgEl.dataset.candidates || '').split('|').filter(Boolean);
    let idx = parseInt(imgEl.dataset.idx || '0', 10) + 1;
    if (idx < list.length) {
      imgEl.dataset.idx = String(idx);
      imgEl.src = list[idx];
    } else {
      // No candidates left â€” remove the image cleanly
      const parent = imgEl.parentNode;
      parent && parent.removeChild(imgEl);
      // Optional: remove credit line if present just below
      const credit = parent?.querySelector?.('.cover-credit');
      if (credit) credit.remove();
    }
  } catch (_) {
    // If anything goes sideways, remove the element
    imgEl.parentNode && imgEl.parentNode.removeChild(imgEl);
  }
}

// Returns the HTML for the image block with all candidates embedded.
// You can pass ev.coverCredit / ev.coverAlt if you add them in JSON.
function buildCoverImgHTML(ev) {
  const candidates = coverCandidates(ev);
  if (!candidates.length) return '';
  const first = candidates[0];
  const alt = (ev.coverAlt || ev.name || 'Cover').replace(/"/g, '&quot;');
  const credit = ev.coverCredit ? 
    `<div class="cover-credit" style="font-size:11px;color:#999;margin:-4px 0 6px;">${ev.coverCredit}</div>` : '';
  return `
    <img
      src="${first}"
      alt="${alt}"
      loading="lazy"
      style="width:100%;max-height:140px;object-fit:cover;border-radius:8px;margin:6px 0;"
      data-candidates="${candidates.join('|')}"
      data-idx="0"
      onerror="tryNextCover(this)"
    />
    ${credit}
  `;
}

  
// â”€â”€â”€ FILTER MARKERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function filterMarkersByVibe() {
  const vibeSearch = document.getElementById('vibeSearchInput').value.trim().toLowerCase();
  const onlyLive = document.getElementById('liveToggle').checked;
  const baseEvents = onlyLive ? eventsToday : globalEvents;

  const filtered = baseEvents.filter(ev => {
    if (!vibeSearch) return true;

    const nameMatch = (ev.name || '').toLowerCase().includes(vibeSearch);
    const vibeMatch = (ev.vibe || '').toLowerCase().includes(vibeSearch);

    return nameMatch || vibeMatch;
  });

  renderMarkers(filtered);
}

// â”€â”€â”€ RENDER MARKERS (with Similar & Add-To-Route) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const markerLayer = L.layerGroup().addTo(map);
// ðŸ”¹ Global cache for all markers (used by the route filter)
window.allMarkers = window.allMarkers || [];

function showRouteControls() {
  const popup = document.querySelector('.leaflet-popup-content');
  console.log("Popup element:", popup);
  console.log("showRouteControls: popup content found?", !!popup);

  if (!popup) return;

  const existingSaveBtn = popup.querySelector('.save-route-btn');
  const existingExportBtn = popup.querySelector('.export-route-btn');
  if (existingSaveBtn) existingSaveBtn.remove();
  if (existingExportBtn) existingExportBtn.remove();

  if (selectedRoute.length >= 2) {
    const saveBtn = document.createElement("button");
    saveBtn.textContent = "ðŸ’¾ Save to My Favorites";
    saveBtn.className = "save-route-btn";
    saveBtn.onclick = () => {
      const existing = localStorage.getItem('savedRoutes');
      const routes = existing ? JSON.parse(existing) : [];
      routes.push([...selectedRoute]);
      localStorage.setItem('savedRoutes', JSON.stringify(routes));
      alert("Crawl saved to favorites!");
    };
    popup.appendChild(saveBtn);

    const exportBtn = document.createElement("button");
    exportBtn.textContent = "Export to Google Maps";
    exportBtn.className = "export-route-btn";
    exportBtn.onclick = () => {
      const base = "https://www.google.com/maps/dir/";
      const waypoints = selectedRoute.map(stop => `${stop.lat},${stop.lon}`).join('/');
      const url = `${base}${waypoints}`;
      window.open(url, "_blank");
    };
    popup.appendChild(exportBtn);
  }
}

function renderMarkers(events, crawlMode = false) {
  markerLayer.clearLayers();
  // ðŸ”¹ Reset and rebuild the global marker cache each render
  window.allMarkers = [];

  const weekdayKeys = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
  const todayIndex = new Date().getDay();

  events.forEach(ev => {
    const lat = Number(ev.lat), lon = Number(ev.lon);
  if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
    console.warn('Skipping invalid coords:', ev.name || ev.title, ev.lat, ev.lon);
    return;
  }
    const rawPart = ev.dayParts?.[weekdayKeys[todayIndex]];
    const isOpen = isLocationOpenNow(ev);
    const markerColor = isOpen && rawPart && rawPart !== '-'
      ? (dayPartColors[rawPart] || 'grey')
      : 'grey';

    const icon = new L.Icon({
      iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-${markerColor}.png`,
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    // ðŸ”¹ Tag each marker with a stable venueId (used for route filtering)
    const venueId = ev.id || ev.name;
    const marker = L.marker([parseFloat(ev.lat), parseFloat(ev.lon)], { icon, venueId });
    marker.ev = ev;

    marker.bindPopup(`<strong>${ev.name}</strong><br>${(ev.vibe || '').split(',').map(v => v.trim()).join(', ')}`);
    marker.on('click', () => {
      map.setView(marker.getLatLng(), 16);
      marker.openPopup();
    });

    if (!crawlMode && eventsToday.includes(ev)) {
      marker.bindTooltip("ðŸ”´ Live Today!", { permanent: true }).addTo(map);
    }

    // ðŸ”¹ Keep an authoritative list of all markers
    window.allMarkers.push(marker);
  });

  window.allMarkers.forEach(marker => {
    const ev = marker.ev;
    const latlng = marker.getLatLng();
    const isOpen = isLocationOpenNow(ev);

    if (crawlMode) {
      // In crawl mode, just add the markers you passed in
      marker.addTo(markerLayer);
      return;
    }

    const thisVibes = (ev.vibe || '')
      .split(',')
      .map(v => v.trim().toLowerCase())
      .filter(Boolean);

    const similar = window.allMarkers
      .filter(m => m !== marker && latlng.distanceTo(m.getLatLng()) <= 350)
      .filter(m => {
        const otherVibes = (m.ev.vibe || '')
          .split(',')
          .map(v => v.trim().toLowerCase())
          .filter(Boolean);
        return thisVibes.some(v => otherVibes.includes(v));
      })
      .slice(0, 3);

    const similarList = similar.length
      ? '<ul>' + similar.map(m => `<li>${m.ev.name}</li>`).join('') + '</ul>'
      : '<em>No similar places nearby.</em>';

    const popupContent = `
  <div style="font-size:14px;line-height:1.4;">
    <strong>${ev.name}</strong><br/>
    ${buildCoverImgHTML(ev)}
    <em>Vibe:</em> ${ev.vibe}<br/>
    <em>Hours:</em> ${ev.hours?.[todayIndex] || 'N/A'}<br/>
    <em>Status:</em> ${isOpen ? '<span style="color:green;">Open Now</span>' : '<span style="color:red;">Closed</span>'}<br/>
    <a href="${ev.link}" target="_blank" rel="noopener">More Info</a>
    <hr/>
    <strong>Could also be the move..:</strong>
    ${similarList}
    <br/><br/>
    <button class="add-route-btn">Add to Route</button>
    <button class="add-fav-btn">Add to Favorites</button>
  </div>
`;



    marker.bindPopup(popupContent).addTo(markerLayer);

    marker.on('popupopen', () => {
      setTimeout(() => {
        const popup = marker._popup.getElement();

        // Add to Route
        const btn = popup.querySelector('.add-route-btn');
        if (btn) {
          console.log("âœ… Add to Route button found for:", ev.name);
          btn.onclick = () => {
            console.log("ðŸŸ¢ Add to Route clicked for:", ev.name);
            addToRoute(ev);
          };
        } else {
          console.warn("âŒ Add to Route button not found in popup");
        }

        // Add to Favorites
        const favBtn = popup.querySelector('.add-fav-btn');
        if (favBtn) {
          console.log("âœ… Add to Favorites button found for:", ev.name);
          favBtn.onclick = () => {
            console.log("â­ Add to Favorites clicked for:", ev.name);
            saveVenueToFavorites(ev);
          };
        } else {
          console.warn("âŒ Add to Favorites button not found in popup");
        }
      }, 50);
    });
  }); // â† missing brace fixed here

  // â”€â”€â”€ ðŸ”’ Keep shared views filtered post-render (if ?route= is present) â”€â”€â”€
  try {
    const params = new URLSearchParams(location.search);
    const q = params.get('route');
    if (q) {
      const ids = q.split(',').map(s => s.trim()).filter(Boolean);
      showOnlyRouteMarkers(map, window.allMarkers || [], ids);
    }
  } catch (e) {
    console.warn('Post-render route filter failed:', e);
  }

  // â”€â”€â”€ ðŸ”” Signal once that markers are fully rendered â”€â”€â”€
  window.dispatchEvent(new CustomEvent('markers:rendered'));
}


  // --- Bootstrap: apply route from URL after markers exist ---
function getRouteIdsFromURL() {
  try {
    const params = new URLSearchParams(location.search);
    const q = params.get('route');
    return q ? q.split(',').map(s => s.trim()).filter(Boolean) : [];
  } catch { return []; }
}

document.addEventListener('DOMContentLoaded', () => {
  const routeIds = getRouteIdsFromURL();
  if (!routeIds.length) return;

  // Apply immediately if markers already exist...
  const tryApply = () => {
    if ((window.allMarkers || []).length) {
      applyRouteFromURL();                 // your existing function (now sets selectedRoute + enables clear)
      window.removeEventListener('markers:rendered', tryApply);
    }
  };

  // ...otherwise wait for renderMarkers to finish
  window.addEventListener('markers:rendered', tryApply);
  tryApply();
});


  function applyRouteFromURL(){
  const params = new URLSearchParams(location.search);
  const route = params.get('route');
  if (!route) return;

  const routeIds = route.split(',').map(s => s.trim()).filter(Boolean);

  // Hide non-route markers immediately
  showOnlyRouteMarkers(map, window.allMarkers || [], routeIds);

  // Rebuild waypoints / route line if desired
  const byId = new Map(globalEvents.map(ev => [ev.id || ev.name, ev]));
  const matchedEvents = routeIds.map(id => byId.get(id)).filter(Boolean);

  // Keep selectedRoute in sync
  window.selectedRoute = matchedEvents;

  const waypoints = matchedEvents.map(loc => 
    L.latLng(parseFloat(loc.lat), parseFloat(loc.lon))
  );

  if (window.routeLayer) map.removeControl(window.routeLayer);
  if (waypoints.length >= 2) {
    window.routeLayer = L.Routing.control({
      waypoints,
      routeWhileDragging: false,
      draggableWaypoints: false,
      addWaypoints: false,
      show: false
    }).addTo(map);
  }

  // âœ… Enable Clear Route button since a route is now active
  if (typeof setClearRouteButtonEnabled === 'function') {
    setClearRouteButtonEnabled(true);
  }
}

// =========================
// Route from a Favorite
// =========================

// --- Config ---
const STAGE_GROUPS = [
  ["coffee","bakery"],                              // 1
  ["fitness"],                                      // 2
  ["market","breakfast","brunch"],                  // 3
  ["park","bookstore","gallery"],                   // 4
  ["lifestyle","random gem"],                       // 5
  ["lunch"],                                        // 6
  ["park","bookstore","gallery","activity"],        // 7
  ["cocktail","random gem"],                        // 8
  ["dinner"],                                       // 9
  ["bar","cocktail","speakeasy","lounge"]           // 10
];

// distance caps (meters)
const DIST_CAP_DEFAULT = 750;
const DIST_CAP_MEAL    = 1500; // breakfast/brunch/lunch/dinner types

// How long to linger and buffer between stops
const DEFAULT_DURATION_HOURS = 1;
const BUFFER_HOURS = 1;

// --- Time helpers you already use elsewhere ---
function _dayKey(d) { return ["sun","mon","tue","wed","thu","fri","sat"][d.getDay()]; }
function _ranges(x){ if(!x) return []; return Array.isArray(x)?x:[x]; }
function _intervalsForDate(d, hours){
  const y=d.getFullYear(), m=d.getMonth(), day=d.getDate();
  const zero = new Date(y,m,day); zero.setHours(0,0,0,0);
  const at = h=> new Date(zero.getTime() + h*3600*1000);
  const out=[];
  _ranges(hours[_dayKey(d)]||[]).forEach(r=>out.push([at(r.open), at(r.close)]));
  const yst = new Date(zero); yst.setDate(zero.getDate()-1);
  _ranges(hours[_dayKey(yst)]||[]).forEach(r=>{
    if(r.close>24){
      const yz = new Date(yst); yz.setHours(0,0,0,0);
      out.push([new Date(yz.getTime()+r.open*3600*1000), new Date(yz.getTime()+r.close*3600*1000)]);
    }
  });
  return out;
}
function isOpenAt(loc, when){
  const hours = loc.hoursNumeric || {};
  return _intervalsForDate(when, hours).some(([o,c])=> when>=o && when<c);
}

// --- Geo helper ---
function distanceMeters(aLat,aLon,bLat,bLon){
  const R=6371000, toRad=d=>d*Math.PI/180;
  const dLat = toRad(bLat-aLat), dLon = toRad(bLon-aLon);
  const la1=toRad(aLat), la2=toRad(bLat);
  const h = Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(h));
}

// --- Vibes overlap helper ---
function vibesArray(loc){
  const v = (loc.vibe || '').split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
  const t = (loc.tags || '').split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
  return Array.from(new Set([...v, ...t]));
}
function vibeOverlapCount(a,b){
  const A = new Set(vibesArray(a));
  let c=0; vibesArray(b).forEach(x=>{ if(A.has(x)) c++;});
  return c;
}

// --- Type normalization ---
function hasType(loc, desired){
  const types = Array.isArray(loc.type)
    ? loc.type.map(t => t.toLowerCase())
    : String(loc.type || '').split(',').map(s => s.trim().toLowerCase());
  return types.some(t => desired.includes(t));
}
function isMealType(loc){
  const meals = ["breakfast","brunch","lunch","dinner"];
  const types = Array.isArray(loc.type)
    ? loc.type.map(t => t.toLowerCase())
    : String(loc.type || '').split(',').map(s => s.trim().toLowerCase());
  return types.some(t => meals.includes(t));
}

// --- Daypart sanity ---
function daypartAllowedForNow(loc, now){
  const dp = (typeof loc.dayParts === 'object' && loc.dayParts !== null && !Array.isArray(loc.dayParts))
    ? loc.dayParts[_dayKey(now)]
    : null;
  if (!dp || dp === '-' ) return true;

  const hour = now.getHours() + now.getMinutes()/60;
  const letter = String(dp).toUpperCase();

  const windowByLetter = {
    M:  [5, 12],
    MD: [10, 15],
    A:  [12, 17],
    HH: [16, 19],
    E:  [17, 24],
    L:  [22, 28],
  };
  const w = windowByLetter[letter];
  if (!w) return true;
  const [start, end] = w;
  if (end <= 24) return hour >= start && hour < end;
  return (hour >= start && hour <= 24) || (hour < (end-24));
}

// --- Stage sequencing ---
function sequencedStagesForNow(now){
  const h = now.getHours() + now.getMinutes()/60;
  let startIdx = 0;
  if (h >= 10.5 && h < 13) startIdx = 2;
  else if (h >= 13 && h < 16) startIdx = 4;
  else if (h >= 16 && h < 19) startIdx = 7;
  else if (h >= 19 && h < 22) startIdx = 8;
  else if (h >= 22 || h < 3) startIdx = 9;
  return STAGE_GROUPS.slice(startIdx).concat(STAGE_GROUPS.slice(0,startIdx));
}

// --- Core route generator ---
function generateRouteFromFavorite(favorite, opts = {}) {
  const now = opts.startTime || new Date();
  const maxStops = opts.maxStops || 6;

  const byId = new Map(globalEvents.map(ev => [ev.id || ev.name, ev]));
  const start = byId.get(favorite.id || favorite.name) || favorite;

  const route = [start];
  let last = start;
  let lastStart = new Date(now);
  let lastDuration = Number(start.duration) || DEFAULT_DURATION_HOURS;

  const stagePlan = sequencedStagesForNow(now);

  const pool = globalEvents
    .filter(ev => (ev.lat && ev.lon))
    .map(ev => ({...ev, lat: parseFloat(ev.lat), lon: parseFloat(ev.lon)}))
    .filter(ev => (ev.id || ev.name) !== (start.id || start.name));

  for (let i = 0; i < stagePlan.length && route.length < maxStops; i++) {
    const desiredTypes = stagePlan[i];
    const arrival = new Date(lastStart.getTime() + (lastDuration + BUFFER_HOURS) * 3600 * 1000);

    let candidates = pool.filter(ev => {
      if (!hasType(ev, desiredTypes)) return false;

      const cap = isMealType(ev) ? DIST_CAP_MEAL : DIST_CAP_DEFAULT;
      const dist = distanceMeters(last.lat, last.lon, ev.lat, ev.lon);
      if (dist > cap) return false;

      if (!daypartAllowedForNow(ev, arrival)) return false;
      if (!isOpenAt(ev, arrival)) return false;
      if (vibeOverlapCount(ev, last) < 1) return false;

      return true;
    });

    if (!candidates.length) continue;

    candidates.forEach(ev => {
      const dist = distanceMeters(last.lat, last.lon, ev.lat, ev.lon);
      const overlap = vibeOverlapCount(ev, last);
      ev.__score = (overlap * 1000) - dist;
    });
    candidates.sort((a,b)=> (b.__score - a.__score));

    const next = candidates[0];
    route.push(next);

    last = next;
    lastStart = arrival;
    lastDuration = Number(next.duration) || DEFAULT_DURATION_HOURS;

    const idx = pool.findIndex(p => (p.id||p.name) === (next.id||next.name));
    if (idx >= 0) pool.splice(idx,1);
  }

  return route;
}


// Reuse-safe: only define if not already present
if (typeof buildGoogleMapsDirUrl !== 'function') {
  function buildGoogleMapsDirUrl(events){
    const base = "https://www.google.com/maps/dir/";
    const waypoints = (events || []).map(e => `${e.lat},${e.lon}`).join('/');
    return `${base}${waypoints}`;
  }
}

function showRouteSummaryPopup(events, title = 'Your Crawl'){
  const items = (events || []).map((e, i) => {
    const safeName = (e.name || `Stop ${i+1}`).replace(/</g,'&lt;').replace(/>/g,'&gt;');
    const href = e.link || '#';
    return `<li><a href="${href}" target="_blank" rel="noopener">${safeName}</a></li>`;
  }).join('');

  const html = `
    <div style="font:14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; max-width:320px;">
      <div style="font-weight:700; margin-bottom:6px;">${title}</div>
      <ol style="padding-left:18px; margin:0 0 8px;">${items}</ol>
      <button id="exportGmapsBtn" style="display:inline-block;padding:6px 10px;border:1px solid #ccc;background:#fff;border-radius:6px;cursor:pointer;">
        Open in Google Maps
      </button>
    </div>
  `;

  // Fit bounds to route and anchor popup near center
  let center = map.getCenter();
  try {
    const bounds = L.latLngBounds(events.map(e => L.latLng(parseFloat(e.lat), parseFloat(e.lon))));
    if (bounds.isValid()) { map.fitBounds(bounds.pad(0.2)); center = bounds.getCenter(); }
  } catch(_){}

  L.popup({ maxWidth: 360 }).setLatLng(center).setContent(html).openOn(map);

  // Wire export
  setTimeout(() => {
    const btn = document.getElementById('exportGmapsBtn');
    if (btn) btn.onclick = () => window.open(buildGoogleMapsDirUrl(events), '_blank');
  }, 0);
}

  
// --- Render route + keep only route markers ---
function renderRouteOnMapFromList(route){
  if (!route || !route.length) return;
  window.selectedRoute = route;

  const ids = route.map(l => l.id || l.name);
  showOnlyRouteMarkers(map, window.allMarkers || [], ids);

  if (window.routeLayer) map.removeControl(window.routeLayer);
  const waypoints = route.map(loc => L.latLng(parseFloat(loc.lat), parseFloat(loc.lon)));
  if (waypoints.length >= 2) {
    window.routeLayer = L.Routing.control({
      waypoints,
      routeWhileDragging: false,
      draggableWaypoints: false,
      addWaypoints: false,
      show: false
    }).addTo(map);
    try {
      const bounds = L.latLngBounds(waypoints);
      if (bounds.isValid()) map.fitBounds(bounds.pad(0.2));
    } catch(_){}
  }

  if (typeof setClearRouteButtonEnabled === 'function') setClearRouteButtonEnabled(true);

  // update URL (?route=...) so itâ€™s shareable
  try {
    const url = new URL(location.href);
    url.searchParams.set('route', ids.join(','));
    history.replaceState(null, '', url.toString());
  } catch(_){}

  // âœ… Show ordered, linked stop list + Google export
  showRouteSummaryPopup(route, 'Route from Favorite');
}

// --- Public entry: start a crawl from a saved favorite by id or name ---
function startCrawlFromFavorite(favIdOrName, options = {}) {
  // fetch favorite from localStorage
  const favs = (() => { try { return JSON.parse(localStorage.getItem('savedFavorites')||'[]'); } catch { return []; }})();
  const fav = favs.find(f => (f.id || f.name) === favIdOrName);
  if (!fav) { alert('Favorite not found.'); return; }

  const route = generateRouteFromFavorite(fav, options);
  if (!route || route.length < 1) { alert('Could not build a route from that favorite.'); return; }
  renderRouteOnMapFromList(route);
}


// ðŸ”¹ Route filtering helpers (keep only markers that are part of the route)
function showOnlyRouteMarkers(map, markers, routeIds) {
  const routeSet = new Set(routeIds);
  markerLayer.clearLayers(); // ðŸ”‘ reset the group to avoid ghosts

  (markers || []).forEach(m => {
    const onRoute = routeSet.has(m.options && m.options.venueId);
    if (onRoute) {
      markerLayer.addLayer(m); // ðŸ”‘ add back into the same group
    }
  });
}

// ðŸ”¹ Convenience: call this right after you set selectedRoute in generateCrawlRoute()
function filterMapToRoute() {
  try {
    const routeIds = (selectedRoute || []).map(l => l.id || l.name);
    showOnlyRouteMarkers(map, window.allMarkers || [], routeIds);
  } catch (e) {
    console.warn('Marker filtering failed:', e);
  }
}

  // --- Ensure expected globals exist ---
window.allMarkers   = window.allMarkers   || [];   // filled by renderMarkers()
window.routeLayer   = window.routeLayer   || null; // L.Routing.control instance
window.routeGroup   = window.routeGroup   || null; // optional LayerGroup for route-only pins
window.selectedRoute= window.selectedRoute|| [];   // your in-memory route array

// Bring all markers back into the visible layer group
function restoreAllMarkers(map, markers) {
  if (!window.markerLayer) {
    console.warn('markerLayer not found; creating a new one');
    window.markerLayer = L.layerGroup().addTo(map);
  }
  markerLayer.clearLayers();
  (markers || []).forEach(m => markerLayer.addLayer(m));
}

// Full clear: remove route line/control, restore markers, reset state + URL
// --- bring all markers back into the visible layer group (NEW) ---
function restoreAllMarkers(map, markers) {
  if (!window.markerLayer) {
    console.warn('markerLayer not found; creating a new one');
    window.markerLayer = L.layerGroup().addTo(map);
  }
  markerLayer.clearLayers();
  (markers || []).forEach(m => markerLayer.addLayer(m));
}

function clearRoute(){
  // 1) Remove the route line / control
  if (window.routeLayer) {
    try { map.removeControl(window.routeLayer); } catch(_) {}
    window.routeLayer = null;
  }

  // 2) Restore ALL markers to the map (via markerLayer)
  restoreAllMarkers(map, window.allMarkers || []);

  // 3) If you used a dedicated route-only group, clear it
  if (window.routeGroup) { try { window.routeGroup.clearLayers(); } catch(_) {} }

  // 4) Reset in-memory route state
  window.selectedRoute = [];

  // 5) Strip ?route= from the URL so reloads don't re-filter the map
  try {
    const url = new URL(location.href);
    if (url.searchParams.has('route')) {
      url.searchParams.delete('route');
      history.replaceState(null, '', url.toString());
    }
  } catch (e) {
    console.warn('URL cleanup failed:', e);
  }

  // 6) (Optional) clear any UI summary
  if (typeof showCrawlSummary === 'function') {
    try { showCrawlSummary([]); } catch(_) {}
  }

  // 7) (Optional) disable the clear button until a new route is built
  setClearRouteButtonEnabled(false);

  console.log('ðŸ§¹ Route cleared and markers restored');
}

// Utility: enable/disable the Clear Route button for good UX
function setClearRouteButtonEnabled(enabled) {
  const btn = document.getElementById('clearRouteBtn');
  if (!btn) return;
  btn.disabled = !enabled;
  btn.style.opacity = enabled ? '1' : '0.6';
  btn.style.cursor  = enabled ? 'pointer' : 'not-allowed';
}

// Wire the Clear Route button (robust to DOM timing) (UPDATED)
(function wireClearRouteButton(){
  const hook = () => {
    const btn = document.getElementById('clearRouteBtn');
    if (!btn) { console.warn('#clearRouteBtn not found in DOM'); return; }
    btn.addEventListener('click', clearRoute);
    // Start disabled until a route exists
    setClearRouteButtonEnabled(!!(window.selectedRoute && window.selectedRoute.length));
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', hook);
  } else {
    hook();
  }
})();

// Call this AFTER you generate a route to enable the button automatically.
// Example: after `selectedRoute = [...crawlRoute]; showCrawlSummary(crawlRoute);`
function onRouteGenerated() {
  setClearRouteButtonEnabled(true);
}

  
fetch('events.json')
  .then(res => res.json())
  .then(events => {
    globalEvents = events;

    // Normalize + validate coordinates for every row
const toNum = v => Number(String(v ?? '').replace(',', '.').replace(/[^\d.\-]/g, ''));

globalEvents = (events || []).map((e, i) => {
  const lat = toNum(e.lat ?? e.latitude);
  const lon = toNum(e.lon ?? e.lng ?? e.longitude);
  return { ...e, lat, lon, __idx: i };
});

// Log the first few invalid rows so you can fix the data
const bad = globalEvents.filter(e => !Number.isFinite(e.lat) || !Number.isFinite(e.lon));
if (bad.length) {
  console.warn('âš ï¸ Invalid coords found:', bad.length);
  console.table(bad.slice(0, 20).map(e => ({
    idx: e.__idx, name: e.name || e.title, lat: e.lat, lon: e.lon
  })));
}


    events.forEach((e, i) => {
  console.log(i, e.name || e.title, e.lat, e.lon || e.lng);
});

    const todayStr = new Date().toISOString().slice(0, 10);
    eventsToday = globalEvents.filter(ev =>
      ev.dateEvents?.some(e => e.date === todayStr)
    );

    console.log("ðŸ“… Events Today:", eventsToday);

   const urlParams = new URLSearchParams(window.location.search);
if (urlParams.has('crawl')) {
  try {
    const crawl = JSON.parse(decodeURIComponent(urlParams.get('crawl')));
    console.log("ðŸ”— Loaded crawl from URL:", crawl);

    renderMarkers(crawl, true); // âœ… pass crawlMode = true
    selectedRoute = [...crawl];
    drawRoute();
    showCrawlSummary(crawl);

    document.querySelector('.controls').style.display = 'none'; // âœ… Hide controls for clean viewer

    return; // â›” Skip default render if crawl loaded
  } catch (e) {
    console.error("Invalid crawl link:", e);
  }
}

    // fallback to default view
    renderMarkers(events);
  })
  .catch(err => {
    console.error('Error loading events:', err);
    alert('Failed to load locations.');
  });


const savedFromStorage = localStorage.getItem('savedRoutes');
if (savedFromStorage) {
  savedRoutes = JSON.parse(savedFromStorage);
}
  
document.getElementById('saveRouteBtn').addEventListener('click', () => {
  console.log('ðŸ§­ selectedRoute at time of save:', selectedRoute); // âœ… moved inside event

  if (selectedRoute.length < 2) {
    alert('Add at least 2 locations to save a route.');
    return;
  }

  savedRoutes.push([...selectedRoute]);
  localStorage.setItem('savedRoutes', JSON.stringify(savedRoutes)); // âœ… persist to localStorage
  console.log('ðŸ” Saved to localStorage:', savedRoutes);
  alert('Route saved to favorites.');
});

document.getElementById('favoritesBtn').addEventListener('click', () => {
  openFavoritesModal();
});

document.getElementById('favoritesBtn').addEventListener('click', () => {
  openFavoritesModal();
});

  document.getElementById('vibeSearchInput').addEventListener('input', () => {
  if (globalEvents.length > 0) {
    filterMarkersByVibe();
  }
});
  
const neighborhoodCenters = {
  // Rome
  "aventino": L.latLng(41.8850, 12.4810),
  "centro storico": L.latLng(41.9028, 12.4534),
  "esquilino": L.latLng(41.8949, 12.5075),
  "flaminio": L.latLng(41.9290, 12.4700),
  "garbatella": L.latLng(41.8760, 12.4790),
  "monteverde": L.latLng(41.8830, 12.4640),
  "monti": L.latLng(41.8954, 12.4930),
  "parioli": L.latLng(41.9190, 12.4840),
  "pigneto": L.latLng(41.8870, 12.5180),
  "prati": L.latLng(41.9092, 12.4533),
  "san lorenzo": L.latLng(41.9032, 12.5180),
  "testaccio": L.latLng(41.8765, 12.4760),
  "trastevere": L.latLng(41.8884, 12.4701),

  // Milan
  "centro storico milan": L.latLng(45.4654, 9.1905),
  "brera": L.latLng(45.4715, 9.1868),
  "navigli": L.latLng(45.4412, 9.1794),
  "porta romana": L.latLng(45.4428, 9.2036),
  "porta venezia": L.latLng(45.4870, 9.2035),
  "porta nuova": L.latLng(45.4804, 9.2029),
  "isola": L.latLng(45.4853, 9.1844),
  "ticinese": L.latLng(45.4423, 9.1773),
  "corso buenos aires": L.latLng(45.4811, 9.2046),
  "cittÃ  studi": L.latLng(45.4791, 9.2227),
  "zona tortona": L.latLng(45.4527, 9.1627),
  "moscova": L.latLng(45.4789, 9.1859)
};


  const crawlFlows = {
  "aperitivo hour": ["market", "lunch", "landmark", "cocktail", "dinner", "wine bar"],
  "foodie feast": ["coffee", "market", "lunch", "wine bar", "dinner", "dessert"],
  "wine & dine": ["gallery", "landmark", "wine bar", "landmark", "dinner", "cocktail", "lounge"],
  "gallery & grandeur": ["gallery", "coffee", "museum", "landmark", "dinner", "cocktail"],
  "leisure & landmarks": ["park", "random gem", "landmark", "lunch", "garden", "landmark", "dinner"],
  "photo walk": ["coffee", "landmark", "landmark", "gallery", "lunch", "cocktail"],
  "family day out": ["breakfast", "park", "museum", "lunch", "landmark", "dinner"],
  "night on the town": ["dinner", "cocktail", "wine bar", "club", "late-night"],
  "mindful mornings": ["fitness", "bakery", "landmark", "market", "garden", "lunch"],
  "midday recharge": ["coffee", "lunch", "landmark", "park", "gallery", "wine â€œbar"]
};

  
  const themeMap = {
  "aperitivo hour": [
  "market", "local", "bites", "aperitivo", "wine", "cocktail", "negroni", "spritz",
  "tapas", "canals", "sunset", "piazza", "bar", "apericena", "snacks", "evening", "aperol",
  "chatter", "friends", "stuzzichini", "golden hour", "buzz", "aperitivo spot",
  "social", "shared plates", "cheese board", "charcuterie", "lively"
],
  "foodie feast": [
  "restaurant", "chef", "osteria", "trattoria", "dining", "pasta", "pizza", "wine",
  "flavors", "street food", "tasting", "bistro", "seasonal", "fresh", "artisan", "dessert", "gelato", "pastry",
  "gourmet", "indulgent", "savory", "hearty", "fusion", "authentic",
  "plating", "creative", "regional", "decadent", "bold"
],
  "wine & dine": [
  "wine bar", "vino", "enoteca", "cocktail", "lounge", "refined", "tasting", "sommelier",
  "romantic", "dinner", "ristorante", "pairing", "moody", "candlelight", "late-night", "intimate",
  "decadent", "elegant", "velvety", "bold", "aromatic", "reserve",
  "cellar", "gourmet", "opulent", "indulgent"
],
  "gallery & grandeur": [
  "gallery", "museum", "art", "exhibit", "architecture", "design", "history", "statues",
  "paintings", "renaissance", "baroque", "grand", "refined", "curated", "elegant", "visual", "cultural",
  "aesthetic", "iconic", "ornate", "timeless", "majestic", "classic",
  "sculpture", "monumental", "masterpiece", "decorative"
],
  "leisure & landmarks": [
  "park", "walk", "stroll", "landmark", "fountain", "monument", "piazza", "historic",
  "casual", "green", "garden", "quiet", "hidden gem", "classic", "viewpoint", "heritage", "relax",
  "scenic", "charming", "iconic", "timeless", "serene", "majestic",
  "wander", "open-air", "picturesque", "peaceful"
],
  "photo walk": [
  "photography", "street", "colorful", "architecture", "hidden corners", "vantage point",
  "piazza", "urban", "statues", "churches", "historic", "murals", "landmark", "composition", "detail",
  "angles", "textures", "shadows", "framing", "scenic", "iconic",
  "vivid", "patterns", "aesthetic", "visuals"
],
  "family day out": [
  "family", "kid-friendly", "park", "museum", "gallery", "casual dining", "gelato",
  "walkable", "piazza", "historic", "educational", "fun", "shared", "outdoors", "cultural", "daytime",
  "playful", "easygoing", "relaxed", "picnic", "memorable", "explore",
  "interactive", "local", "friendly", "cozy"
],
  "night on the town": [
  "bar", "cocktail", "club", "wine bar", "dj", "party", "dance", "lounge", "late-night",
  "music", "crowd", "vibrant", "drinks", "social", "nightlife", "hype", "scene", "energy",
  "glam", "neon", "beats", "buzz", "mixology", "afterhours",
  "trendy", "rowdy", "pulse", "electric"
],
  "mindful mornings": [
  "fitness", "yoga", "bakery", "pastry", "espresso", "market", "wellness", "spa",
  "calm", "garden", "park", "walk", "fresh", "organic", "slow", "serene", "morning",
  "breathe", "stretch", "ritual", "balance", "flow", "refresh",
  "light", "nourish", "soft", "ease"
],
  "midday recharge": [
  "coffee", "espresso", "lunch", "park", "landmark", "garden", "art", "gallery",
  "relaxed", "quiet", "casual", "bookstore", "sunny", "pause", "local", "afternoon",
  "stroll", "breeze", "moment", "reset", "reflect", "peoplewatch",
  "cozy", "easy", "linger", "unwind"
]
};



function matchesTheme(loc, theme) {
  const keywords = themeMap[theme] || [];
  const allTags = [
    ...(loc.vibe || []),
    ...(typeof loc.tags === 'string' ? loc.tags.split(',').map(t => t.trim().toLowerCase()) : [])
  ];
  return keywords.some(kw => allTags.includes(kw));
}

function getCurrentDayPart() {
  const hour = new Date().getHours();
  if (hour >= 6 && hour < 11) return ['M'];
  if (hour >= 11 && hour < 14) return ['MD'];
  if (hour >= 14 && hour < 16) return ['A'];
  if (hour >= 16 && hour < 19) return ['HH'];
  if (hour >= 19 && hour < 22) return ['E'];
  return ['L']; // Late night or overnight
}

 // day key from Date object
function _dayKey(d) {
  return ["sun","mon","tue","wed","thu","fri","sat"][d.getDay()];
}

// normalize to array of {open, close} objects
function _ranges(x) {
  if (!x) return [];
  return Array.isArray(x) ? x : [x];
}

// Get actual open/close Date objects for a given date
function _intervalsForDate(d, hours) {
  const y = d.getFullYear(), m = d.getMonth(), day = d.getDate();
  const zero = new Date(y, m, day);
  zero.setHours(0, 0, 0, 0);

  const at = h => new Date(zero.getTime() + h * 3600 * 1000);

  const out = [];
  // today's ranges
  (_ranges(hours[_dayKey(d)])).forEach(r => {
    out.push([at(r.open), at(r.close)]);
  });

  // yesterday's late ranges (>24h close)
  const yst = new Date(zero);
  yst.setDate(zero.getDate() - 1);
  (_ranges(hours[_dayKey(yst)])).forEach(r => {
    if (r.close > 24) {
      const yZero = new Date(yst);
      yZero.setHours(0, 0, 0, 0);
      out.push([
        new Date(yZero.getTime() + r.open * 3600 * 1000),
        new Date(yZero.getTime() + r.close * 3600 * 1000)
      ]);
    }
  });

  return out;
}

// Check if a location is open at a given datetime
function isOpenAt(loc, when) {
  const hours = loc.hoursNumeric || {};
  return _intervalsForDate(when, hours).some(([o, c]) => when >= o && when < c);
}

  function showCrawlSummary(crawlRoute) {
  const summaryDiv = document.getElementById("crawlSummary");
  summaryDiv.innerHTML = ""; // Clear old content

  const list = document.createElement("ol");
  crawlRoute.forEach((stop, index) => {
    const item = document.createElement("li");
    const link = document.createElement("a");
    link.href = stop.link || "#";
    link.textContent = `Stop ${index + 1}: ${stop.name}`;
    link.target = "_blank";
    item.appendChild(link);
    list.appendChild(item);
  });

  summaryDiv.appendChild(list);

  const saveBtn = document.createElement("button");
  saveBtn.textContent = "ðŸ’¾ Save to My Favorites";
  saveBtn.onclick = () => {
    if (crawlRoute.length < 2) {
      alert('Add at least 2 stops to save a route.');
      return;
    }
    const existing = localStorage.getItem('savedRoutes');
    const routes = existing ? JSON.parse(existing) : [];
    routes.push([...crawlRoute]);
    localStorage.setItem('savedRoutes', JSON.stringify(routes));
    alert("Crawl saved to favorites (local only for now)!");
  };
  summaryDiv.appendChild(saveBtn);

  const exportBtn = document.createElement("button");
  exportBtn.textContent = "Export to Google Maps";
  exportBtn.onclick = () => {
    const base = "https://www.google.com/maps/dir/";
    const waypoints = crawlRoute.map(stop => `${stop.lat},${stop.lng}`).join('/');
    const url = `${base}${waypoints}`;
    window.open(url, "_blank");
  };
  summaryDiv.appendChild(exportBtn);

  function copyShareableRouteLink(crawlRoute){
  const ids = (crawlRoute || []).map(l => l.id || l.name).join(',');
  const url = new URL(location.href);
  url.searchParams.set('route', ids);   // short & robust
  navigator.clipboard.writeText(url.toString()).then(() => {
    alert('Route link copied!');
  }).catch(err => console.warn('Copy failed:', err));
}

// Replace your existing shareBtn.onclick with this:
const shareBtn = document.createElement("button");
shareBtn.textContent = "Copy Crawl Link";
shareBtn.onclick = () => {
  copyShareableRouteLink(selectedRoute || []);
};
  summaryDiv.appendChild(shareBtn);

  const closeBtn = document.createElement("button");
  closeBtn.textContent = "Close";
  closeBtn.onclick = () => {
    summaryDiv.style.display = "none";
  };
  summaryDiv.appendChild(closeBtn);

  summaryDiv.style.display = "block"; // Show it
}
  
// Fixed generateCrawlRoute with real open-time validation and after-midnight handling
function generateCrawlRoute() {
  const todayStr = new Date().toISOString().slice(0, 10);
  if (!globalEvents.length) {
    alert("Locations not loaded yet. Please wait a moment.");
    return;
  }

  const crawlStart = new Date();
  const bufferHours = 1;

  const neighborhood = document.getElementById('neighborhood-input').value.toLowerCase();
  const priceFilter = document.getElementById('priceFilter').value.trim();
  const durationSetting = document.getElementById('durationDropdown').value;
  const neighborhoodCenter = neighborhoodCenters[neighborhood];

  if (!neighborhoodCenter || isNaN(neighborhoodCenter.lat) || isNaN(neighborhoodCenter.lng)) {
    alert("Invalid or missing neighborhood center.");
    return;
  }

  let center = L.latLng(neighborhoodCenter.lat, neighborhoodCenter.lng);
  const maxDuration = durationSetting === 'short' ? 2 : durationSetting === 'medium' ? 5 : 8;
  const rawTheme = document.getElementById('themeDropdown').value;
  const theme = rawTheme.trim().toLowerCase();
  const themeKeywords = (themeMap[theme] || []).map(kw => kw.toLowerCase());

  const priceTiers = ['$', '$$', '$$$', '$$$$'];
  const selectedTierIndex = priceTiers.indexOf(priceFilter);
  const baseDayParts = getCurrentDayPart();
  const themeOverrides = {
    "sunrise start": ["M"],
    "mindful mornings": ["M", "MD"],
    "creative kickstart": ["M", "MD"],
    "midday recharge": ["MD", "A"],
    "health nut": ["M", "MD", "A"],
    "work session": ["M", "MD", "A"],
    "brunch & beyond": ["MD", "A"],
    "late start legends": ["MD", "A", "HH"],
    "post-work wind down": ["HH", "E"],
    "golden hour": ["HH"],
    "foodie tour": ["A", "HH", "E"],
    "chill hang": ["A", "HH", "E"],
    "cheap & cheerful": ["A", "HH", "E"],
    "date night": ["E"],
    "rom-com main character": ["E"],
    "nightcap circuit": ["E", "L"],
    "party time": ["E", "L"],
    "saturday surge": ["E", "L"],
    "weekend warriors": ["L"],
    "tech bro escape": ["E", "L"],
    "self-care": ["M", "MD", "A"],
    "art & culture": ["MD", "A", "E"],
    "artsy & indie": ["A", "E"],
    "solo explorer": ["M", "MD", "A"],
    "rooftops & views": ["HH", "E"],
    "hidden gems": ["E", "L"],
    "sunday reset": ["M", "MD", "A"]
  };
  const currentDayParts = themeOverrides[theme] || baseDayParts;

  const today = new Date();
  const dayKey = today.toLocaleDateString('en-US', { weekday: 'short' }).toLowerCase();

  const allLocations = globalEvents.map(ev => ({
    ...ev,
    lat: parseFloat(ev.lat),
    lng: parseFloat(ev.lon),
    vibe: (ev.vibe || '').split(',').map(v => v.trim().toLowerCase()),
    tags: (ev.tags || '').split(',').map(t => t.trim().toLowerCase())
  }));

  function isOpenAt(loc, dateTime) {
    const weekday = dateTime.toLocaleDateString('en-US', { weekday: 'short' }).toLowerCase();
    const prevWeekday = new Date(dateTime.getTime() - 86400000).toLocaleDateString('en-US', { weekday: 'short' }).toLowerCase();
    const timeDecimal = dateTime.getHours() + dateTime.getMinutes() / 60;

    const todayHours = loc.hoursNumeric?.[weekday];
    const prevHours = loc.hoursNumeric?.[prevWeekday];

    // Check current day normally
    if (todayHours && todayHours.open !== undefined && todayHours.close !== undefined) {
      if (todayHours.close > todayHours.open) {
        if (timeDecimal >= todayHours.open && timeDecimal <= todayHours.close) return true;
      } else {
        // after-midnight case (e.g. 22 to 26)
        if (timeDecimal >= todayHours.open || timeDecimal <= (todayHours.close % 24)) return true;
      }
    }

    // Check if current time falls into after-midnight window from previous day
    if (prevHours && prevHours.close > 24 && timeDecimal <= (prevHours.close % 24)) {
      return timeDecimal <= (prevHours.close % 24);
    }

    return false;
  }

  const openLocations = allLocations.filter(loc => {
    const allKeywords = [...loc.vibe, ...loc.tags];
    const matchesPrice = !priceFilter || (loc.price && priceTiers.indexOf(loc.price) <= selectedTierIndex);
    const matchesTheme = !theme || themeKeywords.some(kw => allKeywords.includes(kw));
    const isCurrentlyOpen = isOpenAt(loc, crawlStart);
    return matchesPrice && matchesTheme && isCurrentlyOpen;
  });

  const validLocations = openLocations.filter(ev => ev.lat && ev.lon && !isNaN(ev.lat) && !isNaN(ev.lon));
  validLocations.forEach(ev => {
    const vibeMatches = ev.vibe.filter(v => themeKeywords.includes(v));
    const tagMatches = ev.tags.filter(t => themeKeywords.includes(t));
    const dist = center.distanceTo(L.latLng(ev.lat, ev.lon));
    ev._score = (vibeMatches.length + tagMatches.length) / (dist + 1);
    ev._score += ev.dateEvents?.some(e => e.date === todayStr) ? 1 : 0;
  });

  const sorted = validLocations.filter(ev => center.distanceTo(L.latLng(ev.lat, ev.lon)) <= 3000).sort((a, b) => b._score - a._score);
  const crawlStages = crawlFlows[theme] || [];
  const crawlRoute = [];
  let timeSpent = 0;
  let lastPoint = center;
  let lastStopStartTime = new Date(crawlStart);
  let lastStopDuration = 0;

  let startingStageIndex = crawlStages.findIndex(stage => {
    return sorted.some(loc => loc.type === stage && themeKeywords.some(kw => [...loc.vibe, ...loc.tags].includes(kw)));
  });

  if (startingStageIndex === -1) {
    alert("No suitable starting point found for this theme.");
    return;
  }

  for (let i = startingStageIndex; i < crawlStages.length; i++) {
    const stage = crawlStages[i];
    const stageCandidates = sorted.filter(loc => {
      const vibeAndTags = [...(loc.vibe || []), ...(loc.tags || [])];
      const typeArray = Array.isArray(loc.type) ? loc.type : String(loc.type).split(',').map(s => s.trim().toLowerCase());
      const matchesType = typeArray.includes(stage.toLowerCase());
      const matchesVibe = themeKeywords.some(kw => vibeAndTags.includes(kw));
      const withinDistance = lastPoint.distanceTo(L.latLng(loc.lat, loc.lon)) <= 1500;
      const fitsTime = timeSpent + (loc.duration || 1) <= maxDuration;

      const arrivalTime = new Date(
        lastStopStartTime.getTime()
        + (lastStopDuration || (crawlRoute[crawlRoute.length - 1]?.duration || 1)) * 3600_000
        + (crawlRoute.length > 0 ? bufferHours * 3600_000 : 0)
      );

      const passesOpenTimeCheck = isOpenAt(loc, arrivalTime);
      return matchesType && matchesVibe && withinDistance && fitsTime && passesOpenTimeCheck;
    });

    if (!stageCandidates.length) continue;
    const next = stageCandidates[0];
    crawlRoute.push(next);
    lastStopStartTime = new Date(
      lastStopStartTime.getTime()
      + (lastStopDuration || (crawlRoute[crawlRoute.length - 2]?.duration || 1)) * 3600_000
      + bufferHours * 3600_000
    );
    lastStopDuration = next.duration || 1;
    timeSpent += lastStopDuration;
    lastPoint = L.latLng(next.lat, next.lon);
    sorted.splice(sorted.indexOf(next), 1);
  }

  if (crawlRoute.length < 2) {
    alert('Could not build a full crawl with available stops.');
    return;
  }

  if (window.routeLayer) map.removeControl(window.routeLayer);
  const waypoints = crawlRoute.map(loc => L.latLng(loc.lat, loc.lon));
  window.routeLayer = L.Routing.control({
    waypoints,
    routeWhileDragging: false,
    draggableWaypoints: false,
    addWaypoints: false,
    show: false
  }).addTo(map);

  selectedRoute = [...crawlRoute];
  showCrawlSummary(crawlRoute);
  filterMapToRoute();
  setClearRouteButtonEnabled(selectedRoute.length >= 2);
  try {
    const routeIds = crawlRoute.map(l => l.id || l.name);
    showOnlyRouteMarkers(map, window.allMarkers || [], routeIds);
  } catch (e) {
    console.warn('Marker filtering failed:', e);
  }
}



   // âœ… Only trigger crawl logic on button click â€” no arguments needed
document.getElementById('crawlNowBtn').addEventListener('click', generateCrawlRoute);

  // Simple modal HTML injection (routes + single-place favorites)
function openFavoritesModal() {
  const routes = (() => {
    try { return JSON.parse(localStorage.getItem('savedRoutes') || '[]'); } catch { return []; }
  })();
  const favs = (() => {
    try { return JSON.parse(localStorage.getItem('savedFavorites') || '[]'); } catch { return []; }
  })();

  console.log('ðŸ“¦ Routes from localStorage:', routes);
  console.log('â­ Favorites from localStorage:', favs);

  let html = `
    <div id="modal" style="position:fixed;top:10%;left:50%;transform:translateX(-50%);background:white;padding:20px;z-index:2000;border:1px solid #ccc;max-height:80%;overflow:auto;box-shadow:0 0 10px rgba(0,0,0,0.3);border-radius:8px;min-width:320px;">
      <h2 style="margin-top:0;">My Favorites</h2>

      <h3 style="margin:12px 0 6px;">Saved Routes</h3>
  `;

  if (!routes.length) {
    html += '<p style="margin:0 0 8px;"><em>No routes saved.</em></p>';
  } else {
    html += '<ul style="padding-left:18px;margin:0 0 8px;">';
    routes.forEach((route, idx) => {
      const title = route[0]?.name ? route[0].name : `Route #${idx + 1}`;
      html += `
        <li style="margin-bottom:10px;">
          <strong>${title}</strong> <em>(${route.length} stops)</em>
          <div style="margin-top:4px;display:flex;gap:6px;flex-wrap:wrap;">
            <button data-idx="${idx}" class="copy-route">Copy Link</button>
            <button data-idx="${idx}" class="load-route">Load</button>
            <button data-idx="${idx}" class="export-route">Open in Google Maps</button>
            <button data-idx="${idx}" class="remove-route">Remove</button>
          </div>
        </li>
      `;
    });
    html += '</ul>';
  }

  html += `
      <h3 style="margin:12px 0 6px;">Saved Places</h3>
  `;

  if (!favs.length) {
  html += '<p style="margin:0 0 8px;"><em>No saved places yet.</em></p>';
} else {
  html += '<ul style="padding-left:18px;margin:0 0 8px;">';
  favs.forEach((f, idx) => {
    const safeName = (f.name || '').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    const href = f.link || '#';
    html += `
      <li style="margin-bottom:10px;">
        <a href="${href}" target="_blank" rel="noopener">${safeName}</a>
        <div style="margin-top:4px;display:flex;gap:6px;flex-wrap:wrap;">
          <button data-idx="${idx}" class="center-fav">Center on Map</button>
          <button data-idx="${idx}" class="build-route-from-fav">Build Route From This</button>
          <button data-idx="${idx}" class="remove-fav">Remove</button>
        </div>
      </li>
    `;
  });
  html += '</ul>';
}


  html += `
      <hr style="margin:12px 0;">
      <div style="text-align:right;">
        <button id="closeModal">Close</button>
      </div>
    </div>
  `;

  document.getElementById('modal')?.remove(); // ensure no duplicate modals
  document.body.insertAdjacentHTML('beforeend', html);

  // Close
  document.getElementById('closeModal').onclick = () => {
    document.getElementById('modal').remove();
  };

  // --- Wire ROUTE actions ---
  // Copy shareable link (?route=ID,ID,...)
  document.querySelectorAll('.copy-route').forEach(btn => {
    btn.onclick = () => {
      const idx = +btn.dataset.idx;
      const route = routes[idx] || [];
      const ids = route.map(l => l.id || l.name).join(',');
      const url = new URL(location.href);
      url.searchParams.set('route', ids);
      navigator.clipboard.writeText(url.toString()).then(() => alert('Route link copied!'));
    };
  });

  // Load on map (filter to route markers, draw line, enable clear)
  document.querySelectorAll('.load-route').forEach(btn => {
    btn.onclick = () => {
      const idx = +btn.dataset.idx;
      const route = routes[idx] || [];
      if (!route.length) return;

      window.selectedRoute = route;

      // Filter markers to route only
      const routeIds = route.map(l => l.id || l.name);
      showOnlyRouteMarkers(map, window.allMarkers || [], routeIds);

      // Build routing line
      if (window.routeLayer) map.removeControl(window.routeLayer);
      const waypoints = route.map(loc => L.latLng(parseFloat(loc.lat), parseFloat(loc.lon)));
      if (waypoints.length >= 2) {
        window.routeLayer = L.Routing.control({
          waypoints,
          routeWhileDragging: false,
          draggableWaypoints: false,
          addWaypoints: false,
          show: false
        }).addTo(map);
      }

      // Recenter and enable Clear
      try {
        const bounds = L.latLngBounds(waypoints);
        if (bounds.isValid()) map.fitBounds(bounds.pad(0.2));
      } catch(_) {}
      if (typeof setClearRouteButtonEnabled === 'function') setClearRouteButtonEnabled(true);

      // Update URL for shareability
      try {
        const url = new URL(location.href);
        url.searchParams.set('route', routeIds.join(','));
        history.replaceState(null, '', url.toString());
      } catch(_) {}

      document.getElementById('modal').remove();
    };
  });

  // Export to Google Maps (fix: use lon, not lng)
  document.querySelectorAll('.export-route').forEach(btn => {
    btn.onclick = () => {
      const idx = +btn.dataset.idx;
      const route = routes[idx] || [];
      const base = "https://www.google.com/maps/dir/";
      const waypoints = route.map(loc => `${loc.lat},${loc.lon}`).join('/'); // âœ… lon
      const url = `${base}${waypoints}`;
      window.open(url, '_blank');
    };
  });

  // Remove route
  document.querySelectorAll('.remove-route').forEach(btn => {
    btn.onclick = () => {
      const idx = +btn.dataset.idx;
      routes.splice(idx, 1);
      localStorage.setItem('savedRoutes', JSON.stringify(routes));
      openFavoritesModal(); // re-render modal
    };
  });

 // --- Wire FAVORITE (single place) actions ---
document.querySelectorAll('.center-fav').forEach(btn => {
  btn.onclick = () => {
    const idx = +btn.dataset.idx;
    const f = favs[idx];
    if (!f) return;
    const lat = parseFloat(f.lat), lon = parseFloat(f.lon);
    if (isFinite(lat) && isFinite(lon)) map.setView([lat, lon], 16);

    // Try to open its existing marker popup if present
    const m = (window.allMarkers || []).find(mk => (mk.options?.venueId === (f.id || f.name)));
    if (m) m.openPopup();
    // Keep modal open so user can act on others, or close if you prefer:
    // document.getElementById('modal').remove();
  };
});

// Build a route starting from this favorite
document.querySelectorAll('.build-route-from-fav').forEach(btn => {
  btn.onclick = () => {
    const idx = +btn.dataset.idx;
    const favs = JSON.parse(localStorage.getItem('savedFavorites') || '[]');
    const f = favs[idx];
    if (!f) return;

    // Your engine entry point (must be defined globally)
    startCrawlFromFavorite(f.id || f.name, { maxStops: 6, startTime: new Date() });

    document.getElementById('modal')?.remove(); // optional: close modal
  };
});


document.querySelectorAll('.remove-fav').forEach(btn => {
  btn.onclick = () => {
    const idx = +btn.dataset.idx;
    favs.splice(idx, 1);
    localStorage.setItem('savedFavorites', JSON.stringify(favs));
    openFavoritesModal(); // re-render modal
  };
});
}


  
</script>
<div style="position: absolute; bottom: 3px; right: 0px; z-index: 1000; background: rgba(255,255,255,0.8); padding: 4px 8px; border-radius: 4px; font-size: 8px;">
  Â© 2025 Roam. All rights reserved. The Roam Appâ„¢ is a trademark of Roam Curated LLC.
</div>
</body>
</html>
